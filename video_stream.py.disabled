"""
Módulo de Streaming de Video
Captura, compresión y transmisión de video encriptado
"""

import cv2
import numpy as np
import threading
import queue
import time
import base64
import zlib
from io import BytesIO


class VideoStream:
    """Gestor de streaming de video"""
    
    def __init__(self, camera_index=0):
        self.camera_index = camera_index
        self.camera = None
        self.is_active = False
        self.camera_enabled = True
        
        # Configuración de video
        self.frame_width = 640
        self.frame_height = 480
        self.fps = 15  # FPS reducido para Tor (bajo ancho de banda)
        self.quality = 50  # Calidad JPEG (1-100)
        
        # Buffers
        self.frame_buffer = queue.Queue(maxsize=5)
        self.outgoing_frames = queue.Queue(maxsize=10)
        
        # Threads
        self.capture_thread = None
        self.encode_thread = None
        
        # Estadísticas
        self.frames_captured = 0
        self.frames_sent = 0
        self.bytes_sent = 0
    
    def start(self):
        """Iniciar captura de video"""
        if self.is_active:
            return
        
        try:
            # Inicializar cámara
            self.camera = cv2.VideoCapture(self.camera_index)
            
            if not self.camera.isOpened():
                print("Error: No se pudo abrir la cámara")
                return False
            
            # Configurar resolución
            self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, self.frame_width)
            self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, self.frame_height)
            self.camera.set(cv2.CAP_PROP_FPS, self.fps)
            
            self.is_active = True
            
            # Iniciar threads
            self.capture_thread = threading.Thread(
                target=self._capture_loop,
                daemon=True
            )
            self.capture_thread.start()
            
            self.encode_thread = threading.Thread(
                target=self._encode_loop,
                daemon=True
            )
            self.encode_thread.start()
            
            print(f"Video stream iniciado: {self.frame_width}x{self.frame_height} @ {self.fps}fps")
            return True
            
        except Exception as e:
            print(f"Error iniciando video stream: {e}")
            return False
    
    def stop(self):
        """Detener captura de video"""
        self.is_active = False
        
        if self.camera:
            self.camera.release()
            self.camera = None
        
        print("Video stream detenido")
    
    def _capture_loop(self):
        """Loop de captura de frames"""
        frame_delay = 1.0 / self.fps
        
        while self.is_active:
            start_time = time.time()
            
            if self.camera_enabled and self.camera:
                ret, frame = self.camera.read()
                
                if ret:
                    # Redimensionar si es necesario
                    if frame.shape[1] != self.frame_width or frame.shape[0] != self.frame_height:
                        frame = cv2.resize(frame, (self.frame_width, self.frame_height))
                    
                    # Agregar a buffer
                    try:
                        self.frame_buffer.put(frame, block=False)
                        self.frames_captured += 1
                    except queue.Full:
                        # Descartar frame si buffer lleno
                        pass
            
            # Mantener FPS constante
            elapsed = time.time() - start_time
            if elapsed < frame_delay:
                time.sleep(frame_delay - elapsed)
    
    def _encode_loop(self):
        """Loop de codificación de frames"""
        while self.is_active:
            try:
                # Obtener frame del buffer
                frame = self.frame_buffer.get(timeout=0.1)
                
                # Codificar frame
                encoded = self._encode_frame(frame)
                
                if encoded:
                    # Agregar a buffer de salida
                    try:
                        self.outgoing_frames.put(encoded, block=False)
                    except queue.Full:
                        pass
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"Error codificando frame: {e}")
    
    def _encode_frame(self, frame):
        """
        Codificar frame para transmisión
        
        Returns:
            String base64 del frame comprimido
        """
        try:
            # Convertir a JPEG
            encode_params = [cv2.IMWRITE_JPEG_QUALITY, self.quality]
            _, buffer = cv2.imencode('.jpg', frame, encode_params)
            
            # Comprimir con zlib
            compressed = zlib.compress(buffer.tobytes(), level=6)
            
            # Codificar en base64
            encoded = base64.b64encode(compressed).decode('utf-8')
            
            self.bytes_sent += len(compressed)
            
            return encoded
            
        except Exception as e:
            print(f"Error en _encode_frame: {e}")
            return None
    
    def get_frame(self):
        """
        Obtener frame actual para visualización local
        
        Returns:
            Frame BGR de OpenCV o None
        """
        try:
            return self.frame_buffer.get(block=False)
        except queue.Empty:
            return None
    
    def get_encoded_frame(self):
        """
        Obtener frame codificado para transmisión
        
        Returns:
            String base64 del frame o None
        """
        try:
            return self.outgoing_frames.get(block=False)
        except queue.Empty:
            return None
    
    @staticmethod
    def decode_frame(encoded_data):
        """
        Decodificar frame recibido
        
        Args:
            encoded_data: String base64 del frame
            
        Returns:
            Frame BGR de OpenCV
        """
        try:
            # Decodificar base64
            compressed = base64.b64decode(encoded_data)
            
            # Descomprimir
            buffer = zlib.decompress(compressed)
            
            # Convertir a array numpy
            nparr = np.frombuffer(buffer, np.uint8)
            
            # Decodificar JPEG
            frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            
            return frame
            
        except Exception as e:
            print(f"Error decodificando frame: {e}")
            return None
    
    def toggle_camera(self):
        """Activar/desactivar cámara"""
        self.camera_enabled = not self.camera_enabled
        return self.camera_enabled
    
    def set_quality(self, quality):
        """
        Ajustar calidad de video (1-100)
        
        Args:
            quality: Nivel de calidad JPEG
        """
        self.quality = max(1, min(100, quality))
        print(f"Calidad de video: {self.quality}")
    
    def set_fps(self, fps):
        """
        Ajustar FPS de captura
        
        Args:
            fps: Frames por segundo (1-30)
        """
        self.fps = max(1, min(30, fps))
        
        if self.camera:
            self.camera.set(cv2.CAP_PROP_FPS, self.fps)
        
        print(f"FPS: {self.fps}")
    
    def get_stats(self):
        """Obtener estadísticas de streaming"""
        return {
            'frames_captured': self.frames_captured,
            'frames_sent': self.frames_sent,
            'bytes_sent': self.bytes_sent,
            'kb_sent': self.bytes_sent / 1024,
            'buffer_size': self.frame_buffer.qsize(),
            'quality': self.quality,
            'fps': self.fps,
            'camera_enabled': self.camera_enabled
        }


class AudioStream:
    """
    Gestor de streaming de audio (básico)
    TODO: Implementar captura y codificación de audio
    """
    
    def __init__(self):
        self.is_active = False
        self.is_muted = False
    
    def start(self):
        """Iniciar captura de audio"""
        # TODO: Implementar con pyaudio o similar
        print("Audio stream: En desarrollo")
        self.is_active = True
    
    def stop(self):
        """Detener captura de audio"""
        self.is_active = False
    
    def toggle_mute(self):
        """Silenciar/activar micrófono"""
        self.is_muted = not self.is_muted
        return self.is_muted


class VideoCallManager:
    """
    Gestor completo de videollamadas
    Coordina video, audio y networking
    """
    
    def __init__(self, p2p_network, crypto_manager):
        self.p2p_network = p2p_network
        self.crypto_manager = crypto_manager
        
        self.video_stream = VideoStream()
        self.audio_stream = AudioStream()
        
        self.is_in_call = False
        self.current_peer = None
        
        self.send_thread = None
        self.receive_thread = None
    
    def start_call(self, peer_onion):
        """
        Iniciar videollamada
        
        Args:
            peer_onion: Dirección .onion del destinatario
        """
        if self.is_in_call:
            return False
        
        # Enviar solicitud de llamada
        self.p2p_network.initiate_call(peer_onion)
        
        self.current_peer = peer_onion
        
        print(f"Llamada iniciada a {peer_onion}")
        return True
    
    def accept_call(self, peer_onion):
        """
        Aceptar videollamada
        
        Args:
            peer_onion: Dirección .onion de quien llama
        """
        if self.is_in_call:
            return False
        
        self.current_peer = peer_onion
        self.is_in_call = True
        
        # Enviar aceptación
        self.p2p_network.accept_call(peer_onion)
        
        # Iniciar streams
        self.video_stream.start()
        self.audio_stream.start()
        
        # Iniciar transmisión
        self._start_transmission()
        
        print(f"Llamada aceptada de {peer_onion}")
        return True
    
    def reject_call(self, peer_onion):
        """
        Rechazar videollamada
        
        Args:
            peer_onion: Dirección .onion de quien llama
        """
        self.p2p_network.reject_call(peer_onion)
        print(f"Llamada rechazada de {peer_onion}")
    
    def end_call(self):
        """Terminar videollamada"""
        if not self.is_in_call:
            return
        
        self.is_in_call = False
        
        # Detener streams
        self.video_stream.stop()
        self.audio_stream.stop()
        
        self.current_peer = None
        
        print("Llamada terminada")
    
    def _start_transmission(self):
        """Iniciar transmisión de A/V"""
        # Thread para enviar frames
        self.send_thread = threading.Thread(
            target=self._send_frames_loop,
            daemon=True
        )
        self.send_thread.start()
        
        # Thread para recibir frames
        self.receive_thread = threading.Thread(
            target=self._receive_frames_loop,
            daemon=True
        )
        self.receive_thread.start()
    
    def _send_frames_loop(self):
        """Loop de envío de frames"""
        while self.is_in_call:
            try:
                # Obtener frame codificado
                encoded_frame = self.video_stream.get_encoded_frame()
                
                if encoded_frame and self.current_peer:
                    # Enviar por P2P
                    self.p2p_network.send_video_frame(
                        self.current_peer,
                        encoded_frame
                    )
                    
                    self.video_stream.frames_sent += 1
                
                time.sleep(1.0 / self.video_stream.fps)
                
            except Exception as e:
                print(f"Error enviando frames: {e}")
    
    def _receive_frames_loop(self):
        """Loop de recepción de frames"""
        # TODO: Implementar recepción y decodificación de frames
        while self.is_in_call:
            time.sleep(0.1)


if __name__ == '__main__':
    # Test de VideoStream
    print("=== Test de VideoStream ===\n")
    
    stream = VideoStream()
    
    if stream.start():
        print("Stream iniciado. Capturando video...")
        print("Presiona 'q' para salir\n")
        
        try:
            while True:
                frame = stream.get_frame()
                
                if frame is not None:
                    # Mostrar frame
                    cv2.imshow('DeepChat Video', frame)
                    
                    # Test de codificación
                    encoded = stream.get_encoded_frame()
                    if encoded:
                        # Decodificar para verificar
                        decoded = VideoStream.decode_frame(encoded)
                        if decoded is not None:
                            cv2.imshow('Decoded', decoded)
                
                # Salir con 'q'
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break
                
                # Mostrar stats cada 5 segundos
                if stream.frames_captured % (stream.fps * 5) == 0:
                    stats = stream.get_stats()
                    print(f"Stats: {stats['frames_captured']} frames, "
                          f"{stats['kb_sent']:.1f} KB enviados")
        
        except KeyboardInterrupt:
            pass
        
        finally:
            stream.stop()
            cv2.destroyAllWindows()
            
            print("\nEstadísticas finales:")
            print(stream.get_stats())
